#  SOLID 원칙
- 단일 책임 원칙
    - single response principle
    - 각 클래스는 하나의 책임만 가지고 있어야 한다.
        - 클래스를 직업에 비유한다면, 한가지 일을 위해 존재하도록 설계
        - 대표적인 업무는 하나여야 한다.
        - 책임에 변경사항이 있을때에만 수정하면되고
        - 책임별로 클래스가 분리되어 있기 때문에 필요에따라 재사용에 용이
    - 다중 책임
        - 각 클래스의 코드가 복잡해지고 역할을 직관적으로 이해하기 어렵다.
        - 책임의 개수만큼 각 클래스를 수정할 이유가 많아진다.
        - 하나의 책임을 수정하는일이 다른 책임들에 의도치않은 영향을 끼칠수 있다.
        - 테스트와 리팩토링, 확장성과 유연성에 제약
- 개방 폐쇄 원칙
    - ocp
    - 확장에는 열려있고 변경에는 닫혀 있어야 한다.
    - 클래스를 수정은하지말고 확장해서 사용한다.
    - 샐호운 케이스들이 추가되면서 코드가 장황해지고 복잡해지고 실수로 기존 과정에 영향을주고, 이미 사용되는 곳에 사이드 이펙을 줄 수 있다.
    - interface 를 정의하여, 책임과 역할을 정의하되 어떻게 수행되는지 구현하지 않는다.
    - 해당 인터페이스를 적용한 클래스들이 이 메서드를 오버라이드해서 각자의 방식으로 책임을 수행.
    - 새로운 형식이 필요하면 해당 인터페이스를 적용한 다른 클래스를 만들면 된다. 이로써 기존의 코드를 수정하는 과정에서 발생할 수 있는 문제들로부터 자유로울 수 있다.
- 리스코프 치환원칙
    - Liskov Substitution Principle
    - 자식클래스는 언제나 부모클래스를 대체할 수 있어야한다.
    - 자식은 최소한 부모가 하는일은 다 해야 한다.
    - 부모 클래스의 객체가 들어갈 자리에 자식 클래스가 들어가도 적어도부모 클래스가 기존에 하던일에는 지장이 없어야 한다.
    - 부모 클래스에서 정상동작하던 메서드가 자식클래스에서 정상동작을 하지 않는다면 lsp 위반.
        - 이 때 해당 메서드는 최고 조상클래스에 물려받는 메서드 아니라 독립된 인터페이스로 존재해야 한다.
- 인터페이스 분리 원칙
    - 클래스는 자신이 사용하지 않을 메소드를 구현하도록 강요받지 않아야 한다.
    - 인터페이스는 자격증과 같은데, 해당 자격증이 필요없는 클래스가 해당 인터페이스를 implements 할 때 해당되지않은 책임을 구현하도록 강요하지 않도록 구현해야한다.
    - 즉, 인터페이스도 책임에 따라 분리되어야 한다.
- 의존성 역전 법칙
    - 고수준 모듈이 저수준 모듈에 의존해서는 안된다.
    - 구체적인 동작을 직접 구현하기 때문에 저수준 모듈, 이를 제어하는 추상화된 로직을 제공하는것을 고수준 모듈이라고 한다.
    - 고수준 모듈에서 저수준 모듈에 의존적이면, 저수준 모듈의 기능을 고수준에서 그대로 사용되기 떄문에 메소드의 이름이나 매개변수가 변경된다면 고수준모듈도 변경되어야 한다.
    - 따라서 저수준 모듈은 인터페이스를 구현하고,  고수준 모듈은 이 인터페이스를 통해 연결되어 저수준 모듈과의 의존성이 역전되게 된다. 
    저수준 모듈에 직접 의존하는 것이 아닌, 인터페이스를 통해 연결 되는 것이다.
    - 이렇게 되면 저수준 모듈의 메소드가 수정되는 것 등 변경 사항이 고수준 모듈에 영향을 주지 않게 된다.
    - 해당 인터페이스를 적용했다면, 해당 인터페이스를 통해 고수준 모듈은 이 다른 클래스들도 연결이 가능하다.
