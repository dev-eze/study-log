# ⚙️ 멀티 스레딩을 사용하셨는데, 스레드를 많이 쓰면 쓸수록 성능이 향상될까요? 
> 인덱싱작업에서 성능향상이 있었던 경우는, 순차적으로 청크사이즈별로 인덱싱하는 작업이 아닌
> 청크사이즈로 동시적으로 인덱싱이 가능한 트랜잭션 속성으로 인해 성능 향상이 있었다.

## 결론부터 말하자면 아니다. 
> 스레드를 무제한으로 늘리면 컨텍스트 스위칭·캐시 미스·GC 압박이 커져 오히려 처리량이 떨어질 수 있다.
> 특히 CPU-바운드 작업이면 CPU 코어 수 + α 이상 늘리는 순간 오버헤드가 성능 이득을 잠식한다.
> 반대로 I/O-바운드라면 대기 시간 비중이 커서 더 많은 스레드를 써도 이득이 있지만, 
> DB커넥션 풀, 레디스, ·원격 API 커넥션 풀처럼 ‘외부 리소스 한계’가 병목이 되면 역시 의미가 없다.
> 결국 프로파일링 → 병목 지점 확인 → 적정 스레드 수를 테스트하며 지정하는 것이 적절하다.

## 실험 기반의 프로파일링이 정답
> 즉 스레드를 무작정 늘리는 것은 만능 해결책이 아니며, 코어·풀·I/O·GC와 같은 다층 병목을 함께 고려해 “측정→조정”해야 진짜 성능이 이뤄질 수 있다.
> 결국 **프로파일링 → 병목 확인 → 적정 수 실험**이 정답입니다.

---

## 스레드 수와 성능 - 정비례하지 않았던 실무 사례 예시
> 실제로는 애플리케이션의 특성, CPU 코어 수, IO 비중에 따라 성능은 오히려 악화될 수도 있다는 걸 경험과 이론으로 배웠다.

### 예시 ② Tomcat 요청 스레드 실험

> Tomcat `maxThreads`를 800 → 2000으로 올렸더니 TPS가 **오히려 5% 감소**  
CPU 사용률은 100% 근접, HikariCP(DB 커넥션 풀 300), Redis 커넥션 풀 200 모두 포화

📌 교훈:
- Tomcat 요청 스레드 수는 `코어 수 × 2` 수준이 적당 (I/O 고려)
- DB 커넥션 풀은 DB 서버 최대 접속 수와 쿼리 시간 기반 산정

💡 적용 후: 지연 시간 20% 감소

---

### 예시 ③ CPU-bound 배치 작업

> 정산 배치에서 암호화·압축 등 연산 집중 작업  
`Runtime.getRuntime().availableProcessors()`를 기준으로 스레드를 `코어 수 + 1`로 한정  
과도한 스레드 수는 문맥 전환 비용으로 인해 **작업당 처리 시간 증가**

---

### 예시 ④ Kafka 컨슈머 그룹 처리량 조절

> Kafka는 1 파티션 = 1 스레드만 읽기 가능  
스레드 수를 파티션 수 이상으로 늘려도 처리량 증가 없음  
오히려 DB 병목이라면 **비동기 배치 인서트 처리**가 더 효과적

---

## 📌 스레드/풀 사이즈 결정 체크리스트

| 범주 | 체크포인트 |
|------|------------|
| ✅ 하드웨어 | • CPU 물리/논리 코어 수<br>• 메모리 용량 (스레드당 스택·객체) |
| ✅ 작업 성격 | • CPU-bound ↔ I/O-bound 비율<br>• 블로킹 호출 수 (DB, API, 파일 I/O) |
| ✅ 외부 시스템 | • DB/Redis/Mongo 커넥션 풀 한계<br>• 외부 API rate limit |
| ✅ JVM 오버헤드 | • 스레드 수 증가 시 GC 비용<br>• 컨텍스트 스위칭·캐시 미스 |
| ✅ 프레임워크 | • Tomcat `maxThreads`, Undertow `io-threads`<br>• WebClient/Feign 커넥션 풀 |
| ✅ 관측 지표 | • TPS, p99 latency, CPU 사용률, GC 시간<br>• DB 평균/최대 연결 수 |

---


---

## ✅ 스레드를 많이 쓰면 동시에 더 많은 작업이 실행 가능하다.

- ✅ **동시성(Concurrency)**을 활용하면 작업 분산이 가능하다.
- ✅ 하지만 **스레드 수가 많다고 항상 성능이 향상되는 것은 아니다.**
- ✅ 실제 성능은 애플리케이션의 특성과 자원 조건에 따라 달라진다.

---

## ✅ 애플리케이션 특성 - 분할 가능성

- 애플리케이션이 **작은 작업 단위로 쪼개어 동시 실행**이 가능한 구조라면 스레드 활용도가 높음
- ❗ **동작이 순차적이거나, 쪼개기 어려운 구조**라면, 스레드 수를 늘려도 **효과가 제한적**임

---

## ✅ 컨텍스트 스위칭(Context Switching)

- ✅ 스레드 간 전환을 위해 CPU가 수행하는 상태 저장/복원 작업
- ✅ 이 과정은 **오버헤드가 크며**, 많을수록 성능 저하 요인

- cpu코어에서 스위칭 작업을 처리하는 동안 오버헤드 발생
- ✅ CPU는 스레드 스케줄링을 위해 **컨텍스트를 메모리에 저장하고 불러오며**, 이 과정에서 **CPU 자원이 낭비됨**

---

## ✅ CPU-bound vs I/O-bound

### 🔸 CPU-bound
- ✅ CPU 연산이 집중되는 작업 (예: 이미지 처리, 대량 수치 계산 등)
- ✅ 코어 수 이상의 스레드를 생성해도 **컨텍스트 스위칭만 늘어나 성능 저하** 가능
- → 보통 **CPU 코어 수 == 스레드 수**가 이상적

### 🔸 I/O-bound
- ✅ 디스크, 네트워크 등 **입출력 대기 시간이 많은 작업**
- ✅ CPU가 자주 idle 상태이므로 **코어 수보다 많은 스레드 수가 유리**
- → 보통 **CPU 코어 수 x 2~4 정도**까지 효율적

---

## ✏️ 보완: 적절한 스레드 수를 결정하는 기준

| 작업 유형     | 추천 스레드 수 기준                         |
|--------------|---------------------------------------------|
| CPU-bound     | `CPU 코어 수` 정도                          |
| I/O-bound      | `CPU 코어 수 x 2 ~ 4` (최적화 필요)         |
| 혼합형         | 프로파일링 기반 조정 (동적 쓰레드풀 추천)   |

> JVM 기반 환경에서는 `Executors.newCachedThreadPool()` 또는 `ThreadPoolExecutor`를 사용할 때  
> 최대 스레드 수 및 큐 용량을 적절히 설정하는 것이 중요하다.
> 보통이 큐 사이즈를 지정하지않으면 무한 (찾아보고 보충)


## 간단 계산
-   Thread Count ≈ CPU Core × (1 + Wait Time / Service Time)

-   Wait Time 거의 없음 → Thread Count ≈ CPU Core

---

### DB 커넥션 풀
-   Max Connections ≤ DB 서버 Core 수 × Factor
-   `Factor`: 쿼리 복잡도 및 병렬성 고려 (보통 2~4)

---

## ✍️ 회고

> CPU-bound 작업이 많은지 컨텍스트 스위칭 오버헤드, I/O 블로킹 여부, 코어 수 등을 고려가 필요하다.
> 즉, 실전에서는 "스레드 수 = 성능"이라는 단순 공식은 적용되지 않는다.  
> 병목 리소스가 어디인지, 작업이 CPU-bound인지 I/O-bound인지부터 파악하고  
> 그에 맞는 스레드 수를 실험 기반으로 산정해야 한다.  
> 특히 DB나 Redis 연결 수 제한처럼 **외부 제약이 스레드 수보다 먼저 오는 경우가 많다.**
> **작업 유형에 맞는 스레드 수 조절**이 필요하다.
