### 📝 **강의 내용 요약**

- 절차 지향 프로그래밍
    - Function
        - 반복가능한, 일정 작업을 묶은 단위를 함수라고 칭한다.
        - 함수의 사용으로 코드의 재사용성, 효율성을 높였지만, 시스템 규모가 커질 수록 코드의 복잡성을 제어하기에는 한계가 있다.
- 객체 지향 프로그래밍
    - Class = 역할 정의
        - 클래스
        - 직업을 정의
        - 각각의 상태를 나타내는 데이터(프로퍼티, 필드, 속성)와 그들이 구사할 함수를 정의한 메소드 (행동)를 갖는다.
    - Method
        - 각 클래스들은 이 행동을 취할 책임이 있다
        - 책임이 메소드라 불리는 함수의 형태로 정의됨.
        - 속성들은 해당 책임을 수행하기 위해 필요한 데이터를 갖는다.
- 역할과 책임을 설계
    - 명령을 내리는것보다 각자의 역할을 정한뒤, 할당된 행동을 명령하는 것이 체계적이고 관리가 용이
- 인스턴스, 객체
    - 클래스라 부르는 역할을 배정받은 객체(object), 인스턴스(instance) 라 부른다.
    - 메소드 = 책임이 중요하다.
    - 객체는 일정한 메모리 자원에 클래스, 즉 역할이 부여된 책임을 가진 존재로 만들어진 결과다.
- 캡슐화
    - 다른 클래스와의 협력을 통해 일을 한다.
    - private한 상태로 외부로부터 감춰져있어 다른 클래스의 객체가 읽거나 수정이 어렵도록 되어있다. ⇒ 캡슐화
        - 내부가 감춰져 있다.
    - 각 클래스가 자기가 맡은 책임에만 관심을 가지게 설계함으로써 코드의 복잡성을 줄이고 유연성을 확보
    - 특정 메소드를 외부에 공개해서 다른 클래스와의 소통창구로 설계
        - 다른클래스가 이를 호출하는데 이를 사용한다.
        - 실행하는 메커니즘이 바뀌든 다른 객체가 이를 호출하는데 영향을 받지 않는다.
    - 서로의 내부사정에 대해 관여할 수 없게 하여 유연성 확복
- 상속 (혈통, 가문)
    - 작업이 커질수록 이에 대한 역할이 방대해지고 커지게 된다.
        - 파생되는 클래스마다 중복되는 기능을 다시 반복해서 작성하는 비효율성이 발생.
        - 공통기능에 수정사항이 있는 경우 이를 모두 일일히 적용해야하는 비효율성.
        - 공통 분모를 가진 해당 클래스들간 아무런 연관성이 표현되지 않는다.
            - 속성과 메소드를 공유하지만 연관성이 없다.
        - 상속
            - 클래스는 다른 클래스에게 속성과 메소드를 물려줄 수 있다. 이를 상속이라고 한다.
            - 자식 클래스는 부모 클래스의 속성과 메소드를 상속받게 된다.
            - 자식 클래스는 기존 클래스, 부모 의 속성과 메소드에 자신만의 추가적인 메소드를 더한 클래스이다.
        - 오버라이딩
            - 특정 메소드를 다른 방식으로 실행할 목적으로 자식클래스를 만들기도 하는데, 이를 오버라이딩이라고 한다.
            - 부모의 메소드를 자식의 방식으로 덮어 씌우는 것.
        - 상속 사용
            - 기존 속성과 메소드에 특정 속성이나 메소드를 추가한 파생 클래스 만들기 위해 사용
            - 특정 메소드의 실행방식을 수정한 클래스를 만들기 위해서도 사용
            - 중복제거로 인한 코드량 감소 뿐 아니라, 서로 다른 클래스를 같은 하나의 카테고리로 묶을 수 있다.
                - 이로 인해 개방 폐쇄가 가능하다.
            - 부모 클래스는 자식 클래스를 묶는 카테고리의 역할을 한다.
            - 카테고리는 특정자리에 어떤 클래스들이 들어갈 수 있는지 정의를 한다.
                - 자식클래스는 부모 클래스로  대체될 수 있다.
                    - 자식클래스는 부모 클래스의 모든 속성, 메소드를 물려받아 갖고 있기 때문에 가능.
        - 서로 다른 클래스를 한 카테고리로 묶고 같은 이름의 책임을 부여하는 방법
- 추상 클래스
    - 혈통과 같다.
    - 여러 클래스를 묶는 카테고리로서의 클래스로 정의될 수 있다.
    - 추상클래스는 그 자체로 객체, 인스턴스를 생성할 수 없다.
    - 추상적인 역할
        - 이름만 있을뿐 뭘 어떻게 하는지 정의되어 있지 않음.
        - 이를 상속받는 자식클래스가 구체화된 자식 클래스로서 역할을 부여받고 정의할 수 있다.
        - 즉, 자식 클래스에서 구체적 역할이 구현이 된다.
- 인터페이스	(자격증)
    - 서로 다른 클래스를 한 카테고리로 묶고 같은 이름의 책임을 부여하는 방법
    - 언어마다 다르다.
    - 서로 완전히 다른 부모에게 속한 클래스도 하나의 카테고리로 묶을 수 있다.
    - 상속이 마치 조상으로 물려받는 가문,혈통이라면 인터페이스는 학위나 자격증과도 같아 혈통에 상관없이 부여받을 수 있다. 즉 여러개 구현 가능.
        - class 독수리<포유류> extends 날다<interface>
        - class 나비<파충류> extends 날다<interface>
    - 인터페이스도 그 자체로 객체를 만들지 못한다.
        - 날다라는 직업은 없다.
    - 인터페이스의 역할
        - 인터페이스를 구현하는 클래스마다 나름의 메소드를 나름의 방식대로 구현
        - 해당 인터페이스를 구현하는 클래스들은 같은 카테고리 안에 속하게 되어, <interface>를 갖는 배열의 자료구조, <interface>를 매개변수로 갖는 함수등에 이들 객체가 들어갈수 있고 이들중 어떤 객체든 대체가 가능하며, 어떤 객체가 사용되냐에  따라 어떻게 행동을 하는지 달라지게 된다. (구현방법이 각각 다르기 때문)
